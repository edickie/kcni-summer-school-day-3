---
title: "Tutorial 02: Bulk Tissue Transcriptomics"
author: "Dr. Shreejoy Tripathy and Keon Arbabi"
date: "26/06/2021"
output: 
  html_document: 
    keep_md: yes
---

### **About this tutorial**

**Main learning objective:** perform cell-type deconvolution to estimate how proportions of cell-types in the brain change in response to various conditions. You can learn more about the Marker Gene Profiles tool by reading the documentation and by reading [Mancarci et al. 2017](https://doi.org/10.1523/ENEURO.0212-17.2017 ) that describes it in greater detail.

We will use `Marker Gene Profiles`, a computational technique that attempts to decompose bulk tissue gene expression into a list of cell-types proportion estimates. 

Cell-type deconvolution requires three components:

1. A set of marker genes per cell type that you want to estimate. We will use the markers that you generated in `tutorial 01` from human scRNA-seq data. 
2. Gene expression measured in bulk tissue samples. We'll use the data generated by [Labonte et al. (2017)](https://doi.org/10.1038/nm.4386)
3. A scientific question you're interested in. We're investigating what cell-types change in response to natural aging and major depression (MDD).

![Conceptualizing Cell Type Proportions in Bulk Tissue.](ctp_ex.png)


### **Load packages**

We will begin by loading the packages necessary for this tutorial, which are already installed in your docker container. If the package is not loading, uncomment the line for installing it. 

```{r basic library loading, message=FALSE, warning=FALSE}

#BiocManager::install("edgeR")
library(edgeR)
#devtools::install_github('oganm/markerGeneProfile', force = T) # install marker gene profile tool from github
library(markerGeneProfile)
#install.packages("tidyverse")
library(tidyverse)
#install.packages("matrixStats")
library(matrixStats)
#install.packages("cowplot")
library(cowplot)
#install.packages("broom")
library(broom)
#install.packages("knitr")
library(knitr)
#install.packages("ggpubr")
library(ggpubr)
theme_set(theme_cowplot())

```

### **Load data**

Next, import the metadata and counts matrix for the bulk RNA-seq we're analyzing. 

```{r, load data, message=FALSE, warning=FALSE}

# import metadata
labonte_meta = read_csv(file = "./data/GSE102556-metadata.csv") %>%
  # grab specific columns and rename for clarity
  select(geo_accession, 
         expr_names, 
         age = age.ch1, 
         gender = gender.ch1, 
         pmi = pmi.ch1, 
         rin = rin.ch1, 
         ph = ph.ch1, 
         phenotype = phenotype.ch1)
# preview 
kable(labonte_meta[1:5,])

# import expression matrix 
labonte_counts = read_tsv("./data/GSE102556-expression-counts.txt") %>%
  # grab column with gene names and samples from the metadata file 
  select(c("gene_symbol", labonte_meta$geo_accession)) %>%
  # remove periods and numbers in gene names used to avoid duplicates 
  mutate(gene_symbol = gsub("\\..*", "", gene_symbol)) %>%
  # filter duplicated genes 
  filter(duplicated(gene_symbol) == FALSE) %>%
  # convert gene_symbol column to rownames 
  column_to_rownames(var = "gene_symbol")

# preview 
kable(labonte_counts[1:5, 1:10])

```

### **Normalize and process**

Because of possible differences in sequencing depth between different bulk brain gene expression samples, we will normalize for these differences using the [Counts Per Million](https://rdrr.io/bioc/edgeR/man/cpm.html) metric in the [`edgeR` package.](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2796818/).   

```{r, normalize}

# normalize using CPM, add 0.1 to every observation, and log2 transform 
labonte_cpm = edgeR::cpm(labonte_counts, log = TRUE, prior.count = 0.1)
# preview
kable(labonte_cpm[1:5, 1:10])

```

Find genes with low standard deviations and remove them from the expression matrix.

```{r, filter low sd}

# calculate standard deviation per row
gene_sds = rowSds(labonte_cpm, na.rm = T) 
# keep rows (genes) with sd greater than 0.1 across all samples 
gene_mat = labonte_cpm[gene_sds > .1, ] %>%
  as.data.frame() %>%
  rownames_to_column(var = "gene_symbol")

```

### **Cell-proportion estimation**

Import the marker gene list you created in `tutorial 1` and reformat.

```{r, import markers}

# import from folder 
marker_data = read.csv(file = "./data/human_markers.csv")[-1] %>%
  # convert class labels to abbreviations
  mutate(class_label = case_when(
    class_label == "Glutamatergic" ~ "Exc",
    class_label == "GABAergic" ~ "Inh")
    ) %>%  
  # add as prefix to subclass labels 
  unite(subclass_label, c(class_label, subclass_label), sep = "_", remove = F, na.rm = T)
# fix any spaces
marker_data$subclass_label = gsub(" ", "_", marker_data$subclass)
# add non-neuronal label back 
marker_data$class_label[is.na(marker_data$class_label)] = "NonN"

# check matches between markers and bulk RNA-seq genes 
paste("marker matches in data: ", length(intersect(unlist(gene_mat$gene), unlist(marker_data$gene))), "/", nrow(marker_data))
# get vector of unique cell types 
cell_types = marker_data$subclass_label %>% unique()
print(cell_types)

# organize markers into a list, which is the format will need for next steps 
marker_list = lapply(cell_types, function(cell_type){
  return(marker_data %>% filter(subclass_label == cell_type) %>% pull(gene) %>% unlist())
  })
names(marker_list) = cell_types

```

Run `mgpEstimate` to get cell type proportions for each bulk tissue sample. 

```{r, cell-type proportion estimation, inlcude=FALSE, message=FALSE, warning=FALSE}

# Run marker gene profile (MGP) analysis
estimations =  mgpEstimate(
  exprData = gene_mat,
  genes = marker_list,
  geneColName = 'gene_symbol',
  outlierSampleRemove = FALSE, # should outlier samples removed. This is done using boxplot stats
  geneTransform = NULL, # this is the default option for geneTransform
  groups = NULL, # if there are experimental groups provide them here. if not desired set to NULL
  seekConsensus = FALSE, # ensures gene rotations are positive in both of the groups
  removeMinority = TRUE)

# get proportion estimates as data frame
estimations_df = as.data.frame(estimations$estimates) %>%
  rownames_to_column(var = "geo_accession")

# proportions are unit-less and negative numbers are just a result of PCA
# we can scale proportions between 0-1 for visualization purposes 
scale0 = function(x){
   (x-min(x))/(max(x)-min(x))
}
estimations_df_norm = scale0(estimations_df[,-1])
estimations_df_norm = estimations_df_norm %>%
  mutate(geo_accession = estimations_df$geo_accession) %>%
  dplyr::select(geo_accession, everything())

# merge cell type proportions with sample metadata
mgp_df = inner_join(labonte_meta, estimations_df_norm, by = "geo_accession") %>%
# pivot longer so there is one row per sample and cell type
# this type of data structure is preferred by ggplot
  pivot_longer(-colnames(labonte_meta),
               names_to = "cell_type",
               values_to = "cell_proportion")
# fix labels 
mgp_df$cell_type = gsub("\\.", "/", mgp_df$cell_type)
# preview 
kable(mgp_df[1:10,])

```

### **Quality-control of cell-proportion estimates**

Let's take a look at some of the quality metrics we have available for MGP calculations when we use the `mgpEstimate` function.

We define our QC algorithm such that it returns a dataframe with the `cell type`, `markers_used` (list of marker genes used per cell type), `removed_marker_ratios` (list of removed marker ratios per cell type), and `percent_variance_PC1` (list of variance explained by the first PC per cell type)

```{r, QC metrics on MGPs, inlcude=FALSE, message=FALSE, warning=FALSE}

# loop through each cell type 
for(i in 1:length(cell_types)){
  # get the expression values of markers kept by mgpEstimate() per bulk sample 
  cells_df = estimations$usedMarkerExpression[i] %>% as.data.frame()
  # get list of markers kept by mgpEstimate()
  masterlist = paste0(rownames(cells_df), collapse=', ')
  # number of markers kept by mgpEstimate()
  num_markers = length(rownames(cells_df))
  # ratio of markers removed
  rm_marker_ratios = estimations$removedMarkerRatios[i]
  # check if the trimmed PCs are not(!) empty (NULL)
  if(!is.null(estimations$trimmedPCAs[[i]])){
    # get the percent variance that each principal component (PC) captures in the data 
    percent_variance = ((summary(estimations$trimmedPCAs[[i]]))[6]) %>% as.data.frame()
    # get the percent variance that the first principal component (PC1) captures in the data 
    percent_variance_PC1 = percent_variance[2,1]
  }
  else{
    # otherwise, the set this to NA
    percent_variance_PC1 = NA
  }
  # build a dataframe with all our metrics
  # initialize dataframe if this is the first iteration of the for() loop
  if(i==1){
    master_df = data.frame("markers_used" = masterlist, 
                           "removed_marker_ratios" = rm_marker_ratios,
                           "percent_variance_PC1" = percent_variance_PC1, 
                           "num_markers" = num_markers)  
  }
  # bind previous iterations results
  else{
    df = data.frame("markers_used" = masterlist, 
                    "removed_marker_ratios" = rm_marker_ratios,
                    "percent_variance_PC1" = percent_variance_PC1, 
                    "num_markers" = num_markers)
    master_df = rbind(master_df, df)
  }
}
QC_metrics = rownames_to_column(master_df, var = "celltype")

```

Let's plot these QC metrics to get a better idea of whats going on in the `mgpEstimate` function.

```{r, QC metrics plots, inlcude=FALSE, message=FALSE, warning=FALSE}

QC_metrics %>%  ggplot(aes(x = celltype, y = num_markers)) +
      theme_minimal() +
      geom_bar(stat = "identity", fill = "#e0abf5") +
      geom_hline(yintercept = 4) + 
      labs(title="Plot of Number of Markers Per Celltype", 
           x="Cell Type", y = "Markers Used")+
      theme(axis.text.x = element_text(angle = 45, vjust = 0.5)) +
      coord_flip()

```

We've drawn a line here where we consider there to be too few markers used to calculate the cell-type proportion estimate for it to be considered robust. Let's look at another measure of the quality of the MGPs, the percent variance explained by PC (principal component) 1. 

```{r, QC metrics plot for PC1, inlcude=FALSE, message=FALSE, warning=FALSE}

QC_metrics %>%  ggplot(aes(x=celltype, y=percent_variance_PC1))+
  geom_bar(stat = "identity", fill =ifelse(QC_metrics$percent_variance_PC1 > 0.35, "#AFEEEE", "#808080")) +
  geom_hline(yintercept = 0.35) +
  labs(title="Percent Variance Explained by Each MGP",
        x="MGPs", y = "Percent Variance Explained by PC 1")+
  theme_minimal()+
  theme(axis.text.x = element_text(angle = 90)) + coord_flip()

```

We consider more than 35% variance explained by PC1 (indicated by the horizontal line) to be a robust cell type proportion estimate. This means all the blue cell type proportion estimates (MGPs) are likely to be good surrogates for cell counts.

Now, let's plot marker gene proportions (MGPs) vs. sample age

```{r, plot mgps, fig.height=6, fig.width=16}

# create a vector of cell types to plot 
plot_genes = c("Exc_IT","Inh_SST","Oligodendrocyte")
# create a list to store plots generated within the for loop
plot_list = list()

# loop through vector of genes to plot
for(i in 1:length(plot_genes)){
  plot_list[[i]] = ggplot(
    # subset by cell type 
    mgp_df %>% filter(cell_type == plot_genes[i]),
    aes(x = age, y = cell_proportion, color = phenotype)) +
    geom_smooth(method = "lm", se = F) + 
    geom_point() +
    ggtitle(paste(plot_genes[i])) +
    ylab(paste(plot_genes[i], " MGP")) + xlab ("sample age (years)") +
    theme_bw() 
}
# bring plots together
plot_grid(plotlist = plot_list, nrow = 1)

```

### **Linear models**

We will use R’s linear modeling function `lm` to fit a statistical model against each cell type proportion and a number of covariates, including gender, pH, RIN (RNA integrity number), PMI (post mortem interval), age, and phenotype (control / MDD).

The model form here is: `cell_type_prop ~ phenotype + gender + ph + rin + pmi + age`

To fit many models with broom, it’s useful to use pivot_longer to stack the data into one column - then group_by() to “split” the stacked data.

```{r, linear models}

# Linear modeling
lm_df = mgp_df %>%
  # each step performed after this line is done with each cell type 
  group_by(cell_type) %>%
  # fit cell type proportions according to this model  
  # using the broom package to tidy the results 
  do(tidy(lm(scale(cell_proportion) ~ phenotype + gender + scale(pmi) + scale(ph) + scale(rin) + scale(age),  data = .))) %>%
  # ungroup the data
  ungroup() %>%
  # adjust for multiple comparisons using the Benjamini-Hochberg method
  mutate(padj = p.adjust(`p.value`, method = 'BH')) %>%
  # clean up variable names 
  mutate(term = recode(term, 
                       `(Intercept)` = "Intercept", 
                       `genderMale` = "gender",
                       `scale(rin)` = "rin",
                       `scale(pmi)` = "pmi",
                       `scale(ph)` = "ph",
                       `scale(age)` = "age",
                       `phenotypeMDD` = "MDD")) %>%
  mutate(class = case_when(
    str_detect(cell_type, "Inh") ~ "Inhibitory",
    str_detect(cell_type, "Exc") ~ "Excitatory",
    TRUE ~ "Non-Neuronal"
  ))

# print data frame for just MDD beta coefficients
kable(lm_df %>% filter(term == 'MDD'))
# print data frame for just age beta coefficients
kable(lm_df %>% filter(term == 'age'))

# beta coeffs per cell type for phenotype 
beta_plot = lm_df %>% 
  filter(term %in% 'MDD') %>% 
  mutate(cell_type = fct_reorder(cell_type, estimate)) %>% 
  ggplot(aes(x = cell_type, y = estimate)) + 
  geom_hline(yintercept = 0) + 
  geom_bar(stat = "identity") + 
  geom_errorbar(aes(ymin = estimate - std.error, ymax = estimate + std.error)) + 
  ggtitle("MDD vs. controls") +
  ylab('Std. Beta coeff.') + 
  xlab('Cell type proportions') + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  facet_wrap(~class, drop = T, scale = "free")
beta_plot

# beta coeffs per cell type for age effects
beta_plot = lm_df %>% 
  filter(term %in% 'age') %>% 
  mutate(cell_type = fct_reorder(cell_type, estimate)) %>% 
  ggplot(aes(x = cell_type, y = estimate)) + 
  geom_hline(yintercept = 0) + 
  geom_bar(stat = "identity") + 
  geom_errorbar(aes(ymin = estimate - std.error, ymax = estimate + std.error)) + 
  ggtitle("Aging Effects") +
  ylab('Std. Beta coeff.') + 
  xlab('Cell type proportions') + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  facet_wrap(~class, drop = T, scale = "free")
beta_plot


```

That concludes the mgpEstimate tutorial. 





















